from math import gcd
from Crypto.Util.number import long_to_bytes

def gcdExtended(a, b):
    # Base Case
    if a == 0 :
        return b,0,1
             
    gcd,x1,y1 = gcdExtended(b%a, a)
     
    # Update x and y using results of recursive
    # call
    x = y1 - (b//a) * x1
    y = x1
     
    return gcd,x,y

def modinv(a, m):
    g, x, y = gcdExtended(a, m)
    if g != 1:
        raise ValueError('Modular inverse does not exist.')
    else:
        return x % m

def attack(c1, c2, e1, e2, N):
    if gcd(e1, e2) != 1:
        raise ValueError("Exponents e1 and e2 must be coprime")

    _,x,y = gcdExtended(e1, e2)

    c2_inv = modinv(c2, N)

    m1 = pow(c1,x,N)
    m2 = pow(c2_inv,-y,N)
    return (m1 * m2) % N

n = 116897025716647102940945662098456390728828241063144677169582932195613653047805103554228029419422974925805423635286644393027042722183225900877783311211425429661359715815043219035473542134916543122669610265438174234545531630110868740559632325930019749695413732866076349615989986603251318166632236404498062270459
e1 = 65537
e2 = 71
c1 = 2490476967347411266074911997167109010591899210194350866810972742009711295099163337410639997279434176891095360474920995361207238752104804073828940599130806982058674647850173805519185281400104939873556481230439089178683062536688827799219839278765610745073935803236946888227503924098134728703490306007612671522
c2 = 69302666448884094567624495089555858864436217106974537746896185756237506639674802992133590515125667832181117720821861745654862740883939872280770308489557370433787421206813444214851857585163890870071838663211282676618019015953441635951367722095177154450367705331088120609408805652990403372891727113510856732568

print(long_to_bytes(attack(c1, c2, e1, e2, n)))